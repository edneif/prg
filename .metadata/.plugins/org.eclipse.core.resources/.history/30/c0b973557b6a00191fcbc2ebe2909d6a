#include <stdio.h>
#include <stdlib.h>

#include "lista_enc.h"
#include "no.h"

#define DEBUG

struct listas_enc {
    no_t *cabeca;   /*!< ReferÃªncia da cabeÃ§a da lista encadeada: primeiro elemento. */
    no_t *cauda;    /*!< ReferÃªncia da cauda da lista encadeada: Ãºltimo elemento. */
    int tamanho;    /*!< Tamanho atual da lista. */
};

/**
  * @brief  Cria uma nova lista encadeada vazia.
  * @param	Nenhum
  *
  * @retval lista_enc_t *: ponteiro (referÃªncia) da nova lista encadeada.
  */
lista_enc_t *criar_lista_enc (void) {
    lista_enc_t *p = malloc(sizeof(lista_enc_t));

    if (p == NULL){
        perror("cria_lista_enc:");
        exit(EXIT_FAILURE);
    }

    p->cabeca = NULL;
    p->cauda = NULL;
    p->tamanho = 0;

    return p;
}


/**
  * @brief  ObtÃ©m a referÃªncia do inÃ­cio (cabeÃ§a) da lista encadeada.
  * @param	lista: lista que se deseja obter o inÃ­cio.
  *
  * @retval no_t *: nÃ³ inicial (cabeÃ§a) da lista.
  */
no_t *obter_cabeca(lista_enc_t *lista){
    return lista->cabeca;
}


/**
  * @brief  ObtÃ©m a referÃªncia da cauda da lista encadeada.
  * @param	lista: lista que se deseja .
  *
  * @retval no_t *:endereço da cuada.
  */
no_t *obter_cauda(lista_enc_t *lista){
        return lista->cauda;


}


/**
  * @brief  Adiciona um nÃ³ de lista no final.
  * @param	lista: lista encadeada que se deseja adicionar.
  * @param  elemento: nÃ³ que serÃ¡ adicionado na cauda.
  *
  * @retval Nenhum
  */
void add_cauda(lista_enc_t *lista, no_t* elemento)
{
    if (lista == NULL || elemento == NULL){
        fprintf(stderr,"add_cauda: ponteiros invalidos");
        exit(EXIT_FAILURE);
    }

   #ifdef DEBUG
   printf("Adicionando %p --- tamanho: %d\n", elemento, lista->tamanho);
   #endif // DEBUG

   //lista vazia
   if (lista->tamanho == 0)
   {
        #ifdef DEBUG
        printf("add_cauda: add primeiro elemento: %p\n", elemento);
        #endif // DEBUG

        lista->cauda = elemento;
        lista->cabeca = elemento;
        lista->tamanho++;
        desligar_no(elemento);
   }
   else if (lista->tamanho == 1)
   {
        // Remove qualquer ligacao antiga
        desligar_no(elemento);
        // Liga cauda da lista com novo elemento
        ligar_nos_primeiro(lista->cauda, elemento);
        lista->cauda = elemento;
        lista->tamanho++;
   }
   else
   {
           // Remove qualquer ligacao antiga
           desligar_no(elemento);
           // Liga cauda da lista com novo elemento
           ligar_nos(lista->cauda, elemento);
           lista->cauda = elemento;
           lista->tamanho++;
      }

}



/**
  * @brief  Adiciona um nÃ³ de lista no incio.
  * @param	lista: lista encadeada que se deseja adicionar.
  * @param  elemento: nÃ³ que serÃ¡ adicionado na cabeca.
  *
  * @retval Nenhum
  */
void add_cabeca(lista_enc_t *lista, no_t* elemento)
{
    if (lista == NULL || elemento == NULL){
        fprintf(stderr,"add_cauda: ponteiros invalidos");
        exit(EXIT_FAILURE);
    }

   #ifdef DEBUG
   printf("Adicionando %p --- tamanho: %d\n", elemento, lista->tamanho);
   #endif // DEBUG

   //lista vazia
   if (lista->tamanho == 0)
   {
        #ifdef DEBUG
        printf("add_cauda: add primeiro elemento: %p\n", elemento);
        #endif // DEBUG

        lista->cauda = elemento;
        lista->cabeca = elemento;
        lista->tamanho++;
        desligar_no(elemento);
   }
   else if (lista->tamanho ==1 )
   {
        // Remove qualquer ligacao antiga
        desligar_no(elemento);
        // Liga cabeca da lista com novo elemento
        ligar_nos_primeiro(lista->cabeca, elemento);
        lista->cabeca = elemento;
        lista->tamanho++;
   }
   else{
	   // Remove qualquer ligacao antiga
	         desligar_no(elemento);
	         // Liga cabeca da lista com novo elemento
	         ligar_nos(lista->cabeca, elemento);
	         lista->cabeca = elemento;
	         lista->tamanho++;


   }


}



void imprimi_lista ( lista_enc_t * lista )
{
	no_t *no = NULL ;
	if ( lista == NULL ){
		fprintf (stderr ," imprimi_lista : ponteiros invalidos ");
		exit ( EXIT_FAILURE );
	}
	no = lista -> cabeca ;
	while (no){
		printf (" Dados : %p\n", obter_dado (no));
		no = obter_proximo (no);
	}
}

void imprimi_lista_tras ( lista_enc_t * lista )
{
	no_t *no = NULL ;
	if ( lista == NULL ){
		fprintf (stderr ," imprimi_lista : ponteiros invalidos ");
		exit ( EXIT_FAILURE );
	}
	no = lista -> cauda ;
	while (no){
		printf (" Dados : %p\n", obter_dado (no));
		no = obter_anterior (no);
	}
}




void exc_cabeca(lista_enc_t *lista)
{

    if (lista->tamanho <= 0)
    {
    	 lista->cabeca = NULL;
    	 lista->cauda = NULL;
    	 lista->tamanho = 0;
    }
    else
    {

    	no_t* cabeca_original = lista->cabeca;
    	no_t* proxima_cabeca = obter_proximo(cabeca_original);
    	no_t* proximo_nova_cabeca = obter_proximo_XOR(lista->cabeca,proxima_cabeca) ;
    	lista->cabeca = proxima_cabeca;
    	lista->tamanho--;
        void* dado = obter_dado(cabeca_original);
        free(cabeca_original);
        free (dado);
        ligar_nos_primeiro(lista->cabeca,proximo_nova_cabeca);

    }




}




void exc_cauda(lista_enc_t *lista)
{


    if (lista->tamanho <= 0)
    {
    	 lista->cabeca = NULL;
    	 lista->cauda = NULL;
    	 lista->tamanho = 0;
    }
    else
    {
    	no_t* cauda_original = lista->cauda;
    	lista->cauda = obter_anterior(cauda_original) ;
    	lista->tamanho--;
    	desligar_no_proximo(lista->cauda);
    	void* dado = obter_dado(cauda_original);
   	    free(cauda_original);
   	    free (dado);


    }



}



